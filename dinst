#!/bin/sh

unset LDFLAGS
unset CFLAGS
unset CPPFLAGS

. ./config


check_root () {
    if [ ! "$($ID_BIN -u)" = "0" ]; then
        error "This command should be run as root in current stage."
        exit
    fi
}


check_command_result () {
    if [ -z "$1" ]; then
        error "No param given for check_command_result()!"
        exit
    fi
    if [ "$1" = "0" ]; then
        debug "CORRECT"
    else
        error
        error "FAILURE! --------------> Last log:"
        $TAIL_BIN -n 20 $LOG
        exit
    fi
}


definition_dir_check () {
    if [ ! -d "$SOFTWARE_DIR" ]; then
        note "No $SOFTWARE_DIR found. Creating one."
        "$MKDIR_BIN" -p "$SOFTWARE_DIR"
    fi
    if [ ! -d "$DEFINITIONS_DIR" ]; then
        note "No definitions folder found. Creating one at: $DEFINITIONS_DIR"
        "$MKDIR_BIN" -p "$DEFINITIONS_DIR"
        note "All definition files (*.def) should be placed there"
    fi
}


check_requirements () {
    definition_dir_check
    if [ "$APPLICATIONS" = "" ]; then
        error "Empty applications list!"
        exit
    fi
}


usage_howto () {
    error "No task param given!"
    error "Built in tasks: destroyall, getshellpath, getshellld, custom-definition-list-file"
    exit
}


. $DEFAULTS
PATH=$DEFAULT_PATH
debug "Default path set ($DEFAULT_PATH)"

if [ ! "$1" = "" ]; then
    case $1 in
        
    destroyall)
        note "All applications and libraries will be permanently destroyed in $SOFTWARE_DIR"
        $RM_BIN -rf "$SOFTWARE_DIR"
        note "Done."
        exit
        ;;
    
    getshellpath)
        result="$DEFAULT_PATH"
        for app in $SOFTWARE_DIR*; do
            if [ -e "${app}/bin" ]; then
                result="${app}/bin:$result"
            fi
            if [ -e "${app}/sbin" ]; then
                result="${app}/sbin:$result"
            fi
            if [ -e "${app}/libexec" ]; then
                result="${app}/libexec:$result"
            fi
        done
        echo "export PATH=$result"
        unset result
        exit
        ;;
    
    getshellld)
        ldresult="/lib:/usr/lib"
        for lib in $SOFTWARE_DIR*; do
            if [ -e "${lib}/lib" ]; then
                ldresult="${lib}/lib:$ldresult"
            fi
            if [ -e "${lib}/libexec" ]; then
                ldresult="${lib}/libexec:$ldresult"
            fi
        done
        echo "export LD_LIBRARY_PATH=$ldresult"
        unset ldresult
        exit
        ;;
        
    *)
        export APPLICATIONS="$($CAT_BIN $1 | $TR_BIN '\n' ' ')"
        note "Parsing definitions: $APPLICATIONS"
        
        ;;
        
    esac
else
    usage_howto
fi



check_requirements
check_root

for application in $APPLICATIONS; do
    
    for definition in "$DEFINITIONS_DIR$application".def; do
        debug "Reading definition: $definition"
        . $DEFAULTS
        . $definition
        
        # fancy old style Capitalize
        APP_NAME="$(echo "$APP_NAME" | $CUT_BIN -c1 | $TR_BIN '[a-z]' '[A-Z]')$(echo "$APP_NAME" | $SED_BIN 's/^[a-zA-Z]//')"
        note
        note "Preparing application: $APP_NAME"
        if [ -z $APP_POSTFIX ]; then
            export PREFIX=$SOFTWARE_DIR$APP_NAME-$APP_VERSION
        else
            export PREFIX=$SOFTWARE_DIR$APP_NAME-$APP_VERSION-$APP_POSTFIX
        fi

        if [ -e $PREFIX ]; then
            note "Application already installed in $PREFIX."
        else
            run () {
                if [ ! -z "$1" ]; then
                    export PATH="$PREFIX/bin:$PREFIX/sbin:$DEFAULT_PATH"
                    export LD_LIBRARY_PATH="$PREFIX/lib:$PREFIX/libexec"
                    debug "PATH: $PATH" >> $LOG
                    debug "CXXFLAGS: $CXXFLAGS" >> $LOG
                    debug "CFLAGS: $CFLAGS" >> $LOG
                    debug "LDFLAGS: $LDFLAGS" >> $LOG
                    debug "LD_LIBRARY_PATH: $LD_LIBRARY_PATH" >> $LOG
                    debug "Current DIR: $BUILD_DIR$dir" >> $LOG
                    definition_dir_check
                    if [ ! -e "$LOG" ]; then
                        $TOUCH_BIN "$LOG"
                    fi        
                    debug "Running '$@' @ `$DATE_BIN`" >> "$LOG"
                    eval PATH=$PATH $@ 1>> "$LOG" 2>> "$LOG"
                    check_command_result $?
                else
                    error "Empty command to run?"
                    exit
                fi
            }
            execute_process () {
                if [ -z "$1" ]; then
                    error "No param given for execute_process()!"
                    exit
                fi
                req_definition_file="$DEFINITIONS_DIR$1.def"
                debug "Checking requirement: $1 file: $req_definition_file"
                if [ ! -e $req_definition_file ]; then
                    error "Definition file for requirement: '$1' does not exists!"
                    exit
                fi
                . $DEFAULTS
                . $req_definition_file
                export ALLOW=1
                if [ ! "$DISABLE_ON" = "" ]; then
                    for disabled in $DISABLE_ON; do
                        debug "Running system: $($UNAME_BIN)"
                        debug "DisableOn element: $disabled"
                        if [ $($UNAME_BIN) = "$disabled" ]; then
                            export ALLOW=0
                        fi
                    done
                fi
                if [ "$ALLOW" = "1" ]; then
                    BUILD_DIR="$TMP_ROOT$APP_NAME-$APP_VERSION/"
                    $MKDIR_BIN -p "$BUILD_DIR"
                    CUR_DIR=$(pwd)
                    cd "$BUILD_DIR"
                    for bd in $BUILD_DIR/*; do
                        if [ -d $bd ]; then
                            debug "Unpacked source code found in build dir. Removing: $bd"
                            $RM_BIN -rf $bd
                        fi
                    done
                    if [ ! -e $BUILD_DIR$1*tar.gz ]; then
                        note "Fetching requirement source from: $APP_HTTP_PATH"
                        run $FETCH_BIN $APP_HTTP_PATH
                    else
                        debug "Already fetched. Using tarball from cache"
                    fi
                    note "Unpacking source code of: $APP_NAME"
                    run $TAR_BIN xf $BUILD_DIR$APP_NAME*
                    debug "Entrering $BUILD_DIR$APP_NAME*" >> $LOG
                    for dir in `$LS_BIN -F $BUILD_DIR | $GREP_BIN \/$`; do
                        debug "Changing dir to: $dir" >> $LOG
                        cd "$dir$APP_SOURCE_DIR_POSTFIX"
                        export CXXFLAGS="-I${PREFIX}/include $APP_COMPILER_ARGS"
                        export CFLAGS="-I${PREFIX}/include $APP_COMPILER_ARGS"
                        export LDFLAGS="-L${PREFIX}/lib $APP_LINKER_ARGS"
                        LIST_DIR=${DEFINITIONS_DIR}patches/$1
                        if [ -d $LIST_DIR ]; then
                            if [ "$1" = "$APP_NAME" ]; then # apply patch only when application/requirement for which patch is designed for
                                debug "Applying patches for application: $application"
                                for patch in $LIST_DIR/*; do
                                    debug "Patching source code with patch: $patch"
                                    run $PATCH_BIN -i "$patch"
                                done
                            fi
                        fi
                        
                        debug "Running configuration script for: $1 with args: --prefix=$PREFIX $APP_CONFIGURE_ARGS"
                        note "Configuring requirement: $1"
                        case $APP_CONFIGURE_SCRIPT in
                            no-conf)
                                note "Skipped configuration for $1"
                                export APP_MAKE_METHOD="$APP_MAKE_METHOD PREFIX=$PREFIX"
                                export APP_INSTALL_METHOD="$APP_INSTALL_METHOD PREFIX=$PREFIX"
                                ;;
                                
                            binary)
                                note "Binary definition: $1"
                                export APP_MAKE_METHOD="true"
                                export APP_INSTALL_METHOD="true"
                                ;;
                                
                            cmake)
                                run $APP_CONFIGURE_SCRIPT . -LH -DCMAKE_INSTALL_PREFIX=$PREFIX
                                ;;
                            
                            *)
                                run $APP_CONFIGURE_SCRIPT $APP_CONFIGURE_ARGS --prefix=$PREFIX
                                ;;
                                
                        esac
                        
                        note "Building requirement: $1"
                        run $APP_MAKE_METHOD
                        note "Installing requirement: $1"
                        run $APP_INSTALL_METHOD
                        if [ ! "$APP_AFTER_INSTALL_CALLBACK" = "" ]; then
                            debug "After install callback: $APP_AFTER_INSTALL_CALLBACK"
                            run $APP_AFTER_INSTALL_CALLBACK
                        fi
                        note "Installed '$1' in: $PREFIX"
                    done
                    cd $CUR_DIR
                else
                    note "This bundle is disabled on current architecture ($($UNAME_BIN)). Skipped"
                fi
            }

            debug "App Requirements: $APP_REQUIREMENTS"
            for req in $APP_REQUIREMENTS; do
                note "Configuring requirement: $req"
                execute_process $req
            done
            execute_process $application
        fi
        
    done
    
done

note "Job's done."
exit
