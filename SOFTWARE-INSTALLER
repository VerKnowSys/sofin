#!/bin/sh


# TODO: resign from APP-VERSION in folder name. Put version into .INSTALLED files!


unset LDFLAGS
unset CFLAGS
unset CPPFLAGS
unset PATH
unset LD_LIBRARY_PATH
unset LD_PRELOAD


# cloading config
if [ ! -e "lib/config" ]; then
    echo "# Unable to find config: lib/config"
    exit
fi
. "lib/config"


# cloading helpers
if [ ! -e "lib/helpers" ]; then
    echo "# Unable to find helpers: lib/helpers"
    exit
fi
. "lib/helpers"


check_command_result () {
    if [ -z "$1" ]; then
        error "No param given for check_command_result()!"
        exit
    fi
    if [ "$1" = "0" ]; then
        debug "CORRECT"
    else
        error
        error "FAILURE! --------------> Last log:"
        $TAIL_BIN -n 50 $LOG
        exit
    fi
}


definition_dir_check () {
    if [ ! -d "$SOFTWARE_DIR" ]; then
        note "No $SOFTWARE_DIR found. Creating one."
        "$MKDIR_BIN" -p "$SOFTWARE_DIR"
    fi
    if [ ! -d "$DEFINITIONS_DIR" ]; then
        note "No definitions folder found. Creating one at: $DEFINITIONS_DIR"
        "$MKDIR_BIN" -p "$DEFINITIONS_DIR"
        note "All definition files (*.def) should be placed there"
    fi
}


check_requirements () {
    definition_dir_check
    if [ "$APPLICATIONS" = "" ]; then
        error "Empty applications list!"
        exit
    fi
}


usage_howto () {
    error "No task param given!"
    error "Built in tasks: list, destroyall, getshellpath, getshellld, one, custom-definition-list-file"
    exit
}


. $DEFAULTS
PATH=$DEFAULT_PATH
debug "Default path set ($DEFAULT_PATH)"

if [ ! "$1" = "" ]; then
    case $1 in

    list)
        note "Listing of installed software:"
        if [ -d $SOFTWARE_DIR ]; then
            note "($LS_BIN -m $SOFTWARE_DIR)"
        else
            note "No software installed"
        fi
        exit
        ;;

    destroyall)
        note "All applications and libraries will be permanently destroyed in $SOFTWARE_DIR"
        $RM_BIN -rf "$SOFTWARE_DIR"
        note "Done."
        exit
        ;;

    getshellpath)
        result="$DEFAULT_PATH"
        for app in $SOFTWARE_DIR*; do
            if [ -L $app ]; then
                if [ -e "${app}/bin" ]; then
                    result="${result}:${app}/bin"
                fi
                if [ -e "${app}/sbin" ]; then
                    result="${result}:${app}/sbin"
                fi
                if [ -e "${app}/libexec" ]; then
                    result="${result}:${app}/libexec"
                fi
            fi
        done
        echo "export PATH=$result"
        unset result
        exit
        ;;

    getshellld)
        ldresult="/lib:/usr/lib"
        for lib in $SOFTWARE_DIR*; do
            if [ -L $lib ]; then
                if [ -e "${lib}/lib" ]; then
                    ldresult="${lib}/lib:$ldresult"
                fi
                if [ -e "${lib}/libexec" ]; then
                    ldresult="${lib}/libexec:$ldresult"
                fi
            fi
        done
        echo "export LD_LIBRARY_PATH=$ldresult"
        unset ldresult
        exit
        ;;

    one)
        if [ "$2" = "" ]; then
            error "For \"one\" application installation mode, second argument with UID is required!"
            exit 1
        fi
        if [ "$3" = "" ]; then
            error "For \"one\" application installation mode, third argument with Application def file name (without extension) is required!"
            exit 1
        fi
        
        note "One app installation mode for given UID: $2 of definition: $3 on the way…"
        export APPLICATIONS="$3"
        export UID="$2"
        note "Parsing definition: $APPLICATIONS"

        ;;
        
    *)
        if [ ! -e $1 ]; then
            error "Definition not found: $1"
            exit 1
        fi
        export APPLICATIONS="$($CAT_BIN $1 | $TR_BIN '\n' ' ')"
        note "Parsing definitions: $APPLICATIONS"
        ;;

    esac
else
    usage_howto
fi


#---------------------------------------------------------------------------


check_requirements

for application in $APPLICATIONS; do

    for definition in "$DEFINITIONS_DIR$application".def; do
        debug "Reading definition: $definition"
        . $DEFAULTS
        . $definition

        # fancy old style Capitalize
        APP_NAME="$(echo "$APP_NAME" | $CUT_BIN -c1 | $TR_BIN '[a-z]' '[A-Z]')$(echo "$APP_NAME" | $SED_BIN 's/^[a-zA-Z]//')"
        note
        note "Preparing application: ${APP_NAME} (${APP_FULL_NAME})"
        if [ -z $APP_POSTFIX ]; then
            if [ $UID = "" ]; then
                export PREFIX="${SOFTWARE_DIR}${APP_NAME}-${APP_VERSION}"
            else
                export PREFIX="${HOME_DIR}${UID}/${HOME_APPS_DIR}${APP_NAME}"
            fi
        else
            if [ $UID = "" ]; then
                export PREFIX=${SOFTWARE_DIR}${APP_NAME}-${APP_VERSION}-${APP_POSTFIX}
            else
                export PREFIX="${HOME_DIR}${UID}/${HOME_APPS_DIR}${APP_NAME}${APP_POSTFIX}"
            fi
        fi

        run () {
            if [ ! -z "$1" ]; then
                export PATH="$PREFIX/bin:$PREFIX/sbin:$DEFAULT_PATH"
                export LD_LIBRARY_PATH="$PREFIX/lib:$PREFIX/libexec"
                debug "PATH: $PATH" >> $LOG
                debug "CXXFLAGS: $CXXFLAGS" >> $LOG
                debug "CFLAGS: $CFLAGS" >> $LOG
                debug "LDFLAGS: $LDFLAGS" >> $LOG
                debug "LD_LIBRARY_PATH: $LD_LIBRARY_PATH" >> $LOG
                debug "Current DIR: $BUILD_DIR$dir" >> $LOG
                definition_dir_check
                if [ ! -e "$LOG" ]; then
                    $TOUCH_BIN "$LOG"
                fi
                debug "Running '$@' @ `$DATE_BIN`" >> "$LOG"
                eval PATH=$PATH "$@" 1>> "$LOG" 2>> "$LOG"
                check_command_result $?
            else
                error "Empty command to run?"
                exit
            fi
        }

        execute_process () {
            if [ -z "$1" ]; then
                error "No param given for execute_process()!"
                exit
            fi
            req_definition_file="$DEFINITIONS_DIR$1.def"
            debug "Checking requirement: $1 file: $req_definition_file"
            if [ ! -e $req_definition_file ]; then
                error "Definition file for requirement: '$1' does not exists!"
                exit
            fi
            . $DEFAULTS
            . $req_definition_file
            export ALLOW=1
            if [ ! "$DISABLE_ON" = "" ]; then
                for disabled in $DISABLE_ON; do
                    debug "Running system: $SYSTEM_NAME"
                    debug "DisableOn element: $disabled"
                    if [ "$SYSTEM_NAME" = "$disabled" ]; then
                        export ALLOW=0
                    fi
                done
            fi

            if [ "$ALLOW" = "1" ]; then
                if [ -z "$APP_HTTP_PATH" ]; then
                    debug "After install callback: $APP_AFTER_INSTALL_CALLBACK"
                    run $APP_AFTER_INSTALL_CALLBACK
                else
                    BUILD_DIR="$TMP_ROOT$APP_NAME-$APP_VERSION/"
                    $MKDIR_BIN -p "$BUILD_DIR"
                    CUR_DIR=$(pwd)
                    cd "$BUILD_DIR"
                    for bd in $BUILD_DIR/*; do
                        if [ -d $bd ]; then
                            debug "Unpacked source code found in build dir. Removing: $bd"
                            $RM_BIN -rf $bd
                        fi
                    done
                    if [ ! -e $BUILD_DIR$1*tar.gz ]; then
                        note "Fetching requirement source from: $APP_HTTP_PATH"
                        run $FETCH_BIN $APP_HTTP_PATH
                    else
                        debug "Already fetched. Using tarball from cache"
                    fi
                    note "Unpacking source code of: $APP_NAME"
                    run $TAR_BIN xf $BUILD_DIR$APP_NAME*
                    debug "Entrering $BUILD_DIR$APP_NAME*" >> $LOG
                    for dir in `$LS_BIN -F $BUILD_DIR | $GREP_BIN \/$`; do
                        debug "Changing dir to: $dir" >> $LOG
                        cd "$dir$APP_SOURCE_DIR_POSTFIX"
                        export CXXFLAGS="-I${PREFIX}/include $APP_COMPILER_ARGS"
                        export CFLAGS="-I${PREFIX}/include $APP_COMPILER_ARGS"
                        export LDFLAGS="-L${PREFIX}/lib $APP_LINKER_ARGS"
                        LIST_DIR=${DEFINITIONS_DIR}patches/$1
                        if [ -d $LIST_DIR ]; then
                            if [ "$1" = "$APP_NAME" ]; then # apply patch only when application/requirement for which patch is designed for
                                note "Applying patches for application: $application"
                                for patch in $LIST_DIR/*; do
                                    debug "Patching source code with patch: $patch"
                                    run $PATCH_BIN -i "$patch"
                                done
                            fi
                        fi

                        debug "Running configuration script for: $1"
                        note "Configuring requirement: $1"
                        case $APP_CONFIGURE_SCRIPT in
                            ignore)
                                note "Ignored configuration part $1"
                                ;;
                                    
                            no-conf)
                                note "Skipped configuration for $1"
                                export APP_MAKE_METHOD="$APP_MAKE_METHOD PREFIX=$PREFIX"
                                export APP_INSTALL_METHOD="$APP_INSTALL_METHOD PREFIX=$PREFIX"
                                ;;

                            binary)
                                note "Binary definition: $1"
                                export APP_MAKE_METHOD="true"
                                export APP_INSTALL_METHOD="true"
                                ;;

                            cmake)
                                run ${APP_CONFIGURE_SCRIPT} . -LH -DCMAKE_INSTALL_PREFIX=$PREFIX
                                ;;

                            *)
                                run ${APP_CONFIGURE_SCRIPT} ${APP_CONFIGURE_ARGS} --prefix=$PREFIX
                                ;;

                        esac

                        note "Building requirement: $1"
                        run "$APP_MAKE_METHOD"
                        note "Installing requirement: $1"
                        run "$APP_INSTALL_METHOD"
                        if [ ! "$APP_AFTER_INSTALL_CALLBACK" = "" ]; then
                            debug "After install callback: $APP_AFTER_INSTALL_CALLBACK"
                            run "$APP_AFTER_INSTALL_CALLBACK"
                        fi
                        note "Marking installed '$1' in: $PREFIX"
                        $TOUCH_BIN "$PREFIX/$1.INSTALLED"
                    done
                    cd $CUR_DIR
                fi
            else
                note "This bundle is disabled on current architecture ($SYSTEM_NAME). Skipped"
            fi
        }

        debug "App Requirements: $APP_REQUIREMENTS"
        for req in $APP_REQUIREMENTS; do
            note "Configuring requirement: $req"
            if [ -e "$PREFIX/$req.INSTALLED" ]; then
                note "Requirement: $req marked as installed. Skipping…"
            else
                export CHANGED="true"
                execute_process $req
            fi
        done

        if [ -e "$PREFIX/$application.INSTALLED" ]; then
            if [ "$CHANGED" = "true" ]; then
                note "At least one of app dependencies has been changed. Forced rebuild of application…"
                execute_process $application
                unset CHANGED
            else
                note "Requirement: $application marked as installed. Skipping…"
            fi
        else
            execute_process $application
        fi

        # make symlink to current version of software only when building relocatable application:
        if [ "$UID" = "" ]; then
            # making app symlink to current version of given app
            req_definition_file="$DEFINITIONS_DIR$application.def"
            . $DEFAULTS
            . $req_definition_file
            APP_NAME="$(echo "$APP_NAME" | $CUT_BIN -c1 | $TR_BIN '[a-z]' '[A-Z]')$(echo "$APP_NAME" | $SED_BIN 's/^[a-zA-Z]//')"
            if [ -z $APP_POSTFIX ]; then
                export PREFIX="${SOFTWARE_DIR}${APP_NAME}-${APP_VERSION}"
            else
                export PREFIX=${SOFTWARE_DIR}${APP_NAME}-${APP_VERSION}-${APP_POSTFIX}
            fi
            note "Removing current symlink to latest version of $APP_NAME"
            $RM_BIN -f $SOFTWARE_DIR$APP_NAME
            note "Making symlink to latest version of $APP_NAME pointing to $SOFTWARE_DIR$APP_NAME"
            $LN_BIN -s $PREFIX $SOFTWARE_DIR$APP_NAME
        fi
            
        note "Marking definition: $application installed"
        $TOUCH_BIN "$PREFIX/$application.INSTALLED"
            
        if [ ! "$UID" = "" ]; then
            note "Setting owner of $PREFIX to UID: $UID"
            $CHOWN_BIN -R $UID "$PREFIX"
        fi

    done

done

note "Adding /etc/profile settings"
shift
echo $($0 getshellpath) > /etc/profile
shift
echo $($0 getshellld) >> /etc/profile

note "Job's done."
exit
